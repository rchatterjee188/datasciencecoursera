---
title: "Code Library"
author: "Ruhika Chatterjee"
date: "2024-12-07"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# R Data Types
- Basic object is vector of same class except list.  
- Atomic classes of objects: character, numeric (real), integer, complex, logical.  
- Attributes can include names, dimnames, dimensions, class, length.

``` {r atomicClass}

# numeric Vector
x <- 5 # numeric vector of 1 element

# integer vector
x <- 5L # integer vector of len 1

x <- Inf # special number infinity, +/-
x <- NaN # special number undefined

# character vector
msg <- "hello" # char vector of len 1

# logical vector
tf <- TRUE # logical vector of value true
# TRUE = 1 = T, FALSE = 0 = F, num > 0 = TRUE

# complex vector
x <- 1+4i # vector of complex num of len 1

```

### complex Data Types
``` {r complexData}
# vector
x <- vector("numeric", length = 10) # create vector of one type, args: class, length
x <- c(1,2,3,4) # creates vector of common denominator class with given values
x <- 1:20 # vector sequence of 20 elements

# lists
# vector capable of carrying different classes
x <- list(1, "a", TRUE, 1+4i) # vector of vectors

# Matrix
# vector of single class with dimensions (an attribute of integer vector len 2)
x <- matrix(nrow=2,ncol=3) # empty matrix of given dimensions
x <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8), nrow = 4, ncol = 2) # creates matrix of given dimensions with values assigned, created by column

x <- 1:10
dim(x) <- c(2,5) # creates matrix out of vector with dimension 2 rows x 5 columns

cbind(1:3,10:12) # creates matrix out of values in vector args, adding by column (1st arg = 1st col)
rbind(1:3,10:12) # same but using rows

# factors
# self-describing type of vector representing categorical data, ordered or unordered (labels)
x <- factor(c("male","female","female","female","male")) # character vector with specific linear modeling capabilities, levels also in output

# data frames
# stores tabular data, stored as lists of same length where each element is a column, length of element is number of rows. Different classes possible
x <- data.frame(foo=1:4, bar=c(T,T,F,F)) # creates data frame 2 columns foo and bar, 4 rows unnamed
x <- read.table(hw1_data.csv) # read in data from file
x <- read.csv(hw1_data.csv) # same
row.names() # get and set row names
nrow(x) # number of rows
ncol(x) # number of columns
data.matrix() # converts data frame to matrix, coercion

# names attribute
x <- 1:3
names(x) # is null
names(x) <- c("foo","bar","norf") #now not numbered vector but named, print x and names(x) with names
# also for lists, names vectors not items
m <- matrix(1:4,nrow = 2, col = 2)
dimnames(m) <- list(c("a","b"),c("c","d")) # each dimension has a name for matrices, rows names then columns

```


# Basic R Functions
``` {r}
# managing working directory and work space
getwd() # find working directory
read.csv("hw1_data.csv") # reads in data from csv file named from directory
dir() # output files in directory
ls() # prints the objects in work space
source("myCode.R") # load code into console

# Input and Evaluation
x <- 1 # assignment operator, evaluates and returns
print(x) # print value as vector
x # auto-prints

# Functions on Objects
attributes(x) # function to return or modify attributes of object
c(0.5,0.8,10) # creates a vector of a certain class otherwise coercion
as.numeric(0:6) # explicit coersion, works on all atomic classes, if not possible converts to NA and warning

# Factors functions
x <- factor(c("male","female","female","female","male")) # can include levels argument to set order (baseline is first) otherwise alphabetical
x # prints values in vector and levels
table(x) # prints labels and counts present
unclass(x) # strips class to integer with levels of labels

# Missing Values
# represented as NA (missing, with specified class) or NaN (missing or undefined)
# NaN is NA but NA not always NaN
is.na() # output logical vector of length of input
is.nan() # output logical vector of length of input

```

``` {r defFunctions}
myfunction <- function(){ #create a function
  x <- rnorm(100)
  mean(x)
}
myfunction() #call created function

myaddedfunction <- function(args){ #create a function with argument
  x <- args + rnorm(100)
  mean(x)
}
myaddedfunction(5)
myaddedfunction(4:10)

```



# R Packages
- Repositories: CRAN, BioConductor (bioinformatics), GitHub  
- Search: https://www.rdocumentation.org/  

- Base packages: utils, stats, datasets, graphics, grDevices, grid, methods, tools, parallel, compiler, splines, tcltk, stats4.  
- Recommended packages: boot, class, cluster, codetools, foreign, KernSmooth, lattice, mgcv, nime, rpart, survival, MASS, spatial, nnet, Matrix.  
``` {r}
version #R info version
sessionInfo() #R info version, packages

# Install from CRAN:
#   install.packages("ggplot2", repos = "http://cran.us.r-project.org") #install
#   install.packages(c("labeling","tibble"), repos = "http://cran.us.r-project.org") #multiple

# Install from Bioconductor
#   install.packages("BiocManager", repos = "https://bioconductor.org/biocLite.R")
#   BiocManager::install(c("GenomicFeatures", "AnnotationDbi")) #install package

# Install from GitHub (need package, author name)
#   install.packages("devtools", repos = "http://cran.us.r-project.org") #only once
#   library(devtools)
#   install_github("author/package") #installs package

# library(ggplot2)# Load package, careful of dependencies
# installed.packages() #check installed packages
# library() #alternate
# old.packages(repos = "http://cran.us.r-project.org") #check packages to update
# update.packages(repos = "http://cran.us.r-project.org") #update all packages
# install.packages("ggplot2") #to update single package
# detach("package:ggplot2", unload=TRUE) #unload function
# remove.packages("ggtree") #remove package
# help(package = "ggplot2") #package info
# browseVignettes("ggplot2") #extended help files

```


# Data in R

``` {r workingData}

# Read data into R
x <- read.table(hw1_data.csv) #reading tabular data from text files, return data frame. Args: file (name, connection), header (logical if header line present), sep (string indicating column separator), colClasses (character vector of class of each column), nrows (number of rows), comment.char (character string indicating comment character), skip (number of lines to skip from beginning), stringsAsFactors (logical if character variables coded as factors, default true). Efficient. Default separator " " and header = FALSE. Check help page to optimize for large datasets, set comment.char = "" to optimize if no comments present, use colClasses, nrow (memory).
x <- read.csv(hw1_data.csv) # Same but default separator is ", "  and header = TRUE
write.table()

# help read.table with colClasses with smaller sample
initial <- read.table("hw1_data.csv",nrows = 100)
classes <- sapply(initial, class)
tabAll <- read.table("hw1_data.csv", colClasses = classes)

lines <- readLines # reading lines of text file, return character vector
wirteLines()

# editable textual format retains metadata, helpful for version control, corruption fixable, memory cost
dget(coded.R) # reading R objects deparsed into text files
dput() # takes R object, create R code to reconstruct object saving attributes, names
source(coded.R) # reading in R code files
dump() # multiple R objects

load() # read in saved workspace read binary objects into R
save()
unserialize() # read single R objects in binary form
serialize()

```
